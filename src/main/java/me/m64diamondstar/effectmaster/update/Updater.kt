package me.m64diamondstar.effectmaster.update

import me.m64diamondstar.effectmaster.EffectMaster
import me.m64diamondstar.effectmaster.data.Configuration
import me.m64diamondstar.effectmaster.shows.EffectShow
import me.m64diamondstar.effectmaster.shows.utils.ShowUtils

class Updater: Configuration("", "updater") {

    private val updates = listOf(
        Update(Version(1, 5, 0)) {
            ShowUtils.getAllShows()
                .map { it.first.nameWithoutExtension to it.second.nameWithoutExtension }
                .forEach { (category, show) ->
                    val effectShow = EffectShow(category, show)

                    effectShow.getAllEffects().forEach { id, effect ->
                        if (effect?.getIdentifier() in listOf(
                                "BLOCK_PATH",
                                "FOUNTAIN_PATH",
                                "ITEM_FOUNTAIN_PATH",
                                "PARTICLE_PATH"
                            )
                        ) {
                            val smooth = effect?.getSection(effectShow, id)?.getBoolean("Smooth") == true
                            effect?.getSection(effectShow, id)?.set("SplineType", if (smooth) "BEZIER" else "POLY_CHAIN")
                            effect?.getSection(effectShow, id)?.set("Smooth", null)
                            effectShow.saveConfig()
                        }
                    }
                }
        }
    )

    fun initialize() {
        val header = listOf(
            "==========================================",
            "CAUTION: do NOT edit this file manually.",
            "It can lead to the plugin not functioning as it should.",
            "=========================================="
        )

        this.getConfig().options().setHeader(header)

        val oldVersion = getOldVersion()
        val currentVersion = getCurrentVersion()

        if (oldVersion < currentVersion) {
            EffectMaster.plugin().logger.warning("Plugin has been updated... Searching for changes to be executed")

            val updatesToApply = updates.filter { it.version > oldVersion }

            if (updatesToApply.isEmpty()) {
                EffectMaster.plugin().logger.info("No necessary changes were found. Continuing the start up...")
                return
            }

            EffectMaster.plugin().logger.info("Found ${updatesToApply.size} change" + if (updatesToApply.size == 1) "." else "s.")
            updatesToApply.forEach { update ->
                EffectMaster.plugin().logger.info("Executing changes for update 1.5.0...")
                update.executor.run()
            }

            EffectMaster.plugin().logger.info("All changes have been made and the version has been updated.")
            this.getConfig().set("version", currentVersion.toString())
        }

        this.reloadConfig()
    }

    private fun getOldVersion(): Version {
        return Version.parse(this.getConfig().getString("version") ?: "0.0.0")
    }

    private fun getCurrentVersion(): Version {
        return Version.parse(EffectMaster.plugin().description.version)
    }

    private data class Update(
        val version: Version,
        val executor: Runnable
    )
}