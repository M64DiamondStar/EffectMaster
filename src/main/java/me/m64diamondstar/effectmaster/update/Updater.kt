package me.m64diamondstar.effectmaster.update

import me.m64diamondstar.effectmaster.EffectMaster
import me.m64diamondstar.effectmaster.data.Configuration
import me.m64diamondstar.effectmaster.shows.EffectShow
import me.m64diamondstar.effectmaster.shows.utils.ShowUtils

class Updater: Configuration("", "updater") {

    private val updates = listOf(
        // Fix  spline type rename
        Update(Version(1, 5, 0)) {
            ShowUtils.getAllShows()
                .map { it.first.nameWithoutExtension to it.second.nameWithoutExtension }
                .forEach { (category, show) ->
                    val effectShow = EffectShow(category, show)

                    effectShow.getAllEffects().forEach { (id, effect) ->
                        if (effect?.getIdentifier() in listOf(
                                "BLOCK_PATH",
                                "FOUNTAIN_PATH",
                                "ITEM_FOUNTAIN_PATH",
                                "PARTICLE_PATH"
                            )
                        ) {
                            val smooth = effect?.getSection(effectShow, id)?.getBoolean("Smooth") == true
                            effect?.getSection(effectShow, id)?.set("SplineType", if (smooth) "BEZIER" else "POLY_CHAIN")
                            effect?.getSection(effectShow, id)?.set("Smooth", null)
                            effectShow.saveConfig()
                        }
                    }
                }
        },

        // Update config.yml prefixes (switched to using minimessage)
        Update(Version(1, 5, 0, "beta2")) {
            val config = EffectMaster.plugin().config
            config.set("messages", null)
            config.set("prefix.normal", "<b><gradient:#9156F5:#E23DC5>EffectMaster<reset> <#7d7d7d>» <#bfbfbf>")
            config.set("prefix.short", "<b><#b34ce6>E<#bd49e1>M<reset> <#7d7d7d>» <#bfbfbf>")
            EffectMaster.plugin().saveConfig()

            ShowUtils.getAllShows()
                .map { it.first.nameWithoutExtension to it.second.nameWithoutExtension }
                .forEach { (category, show) ->
                    val effectShow = EffectShow(category, show)

                    effectShow.getAllEffects().forEach { (id, effect) ->
                        if (effect?.getIdentifier() in listOf(
                                "PARTICLE",
                                "PARTICLE_EMITTER",
                                "PARTICLE_LINE",
                                "PARTICLE_PATH"
                            )
                        ) {
                            val dX = effect?.getSection(effectShow, id)?.getDouble("dX") ?: 0.0
                            val dY = effect?.getSection(effectShow, id)?.getDouble("dY") ?: 0.0
                            val dZ = effect?.getSection(effectShow, id)?.getDouble("dZ") ?: 0.0

                            effect?.getSection(effectShow, id)?.set("Delta", "$dX, $dY, $dZ")
                            effect?.getSection(effectShow, id)?.set("dX", null)
                            effect?.getSection(effectShow, id)?.set("dY", null)
                            effect?.getSection(effectShow, id)?.set("dZ", null)
                            effectShow.saveConfig()
                        }
                    }
                }
        }
    )

    fun initialize() {
        val header = listOf(
            "==========================================",
            "CAUTION: do NOT edit this file manually.",
            "It can lead to the plugin not functioning as it should.",
            "=========================================="
        )

        this.getConfig().options().setHeader(header)

        val oldVersion = getOldVersion()
        val currentVersion = getCurrentVersion()

        if (oldVersion < currentVersion) {
            EffectMaster.plugin().logger.warning("Plugin has been updated... Searching for changes to be executed")

            val updatesToApply = updates.filter { it.version > oldVersion }

            if (updatesToApply.isEmpty()) {
                EffectMaster.plugin().logger.info("No necessary changes were found. Continuing the start up...")
                return
            }

            EffectMaster.plugin().logger.info("Found ${updatesToApply.size} change" + if (updatesToApply.size == 1) "." else "s.")
            updatesToApply.forEach { update ->
                EffectMaster.plugin().logger.info("Executing changes for update $currentVersion...")
                update.executor.run()
            }

            EffectMaster.plugin().logger.info("All changes have been made and the version has been updated.")
            this.getConfig().set("version", currentVersion.toString())
        }

        this.reloadConfig()
    }

    private fun getOldVersion(): Version {
        return Version.parse(this.getConfig().getString("version") ?: "0.0.0")
    }

    private fun getCurrentVersion(): Version {
        return Version.parse(EffectMaster.plugin().pluginMeta.version)
    }

    private data class Update(
        val version: Version,
        val executor: Runnable
    )
}